/**
 * Verified Electronics â€” FAST Dialpad Leaderboard (TEST BUILD)
 * Paths:
 *   /calls?limit=50[&cursor=â€¦]
 *   /leaderboard?from=YYYY-MM-DD&to=YYYY-MM-DD[&cap=80][&force=true]
 *   /                 -> usage help (so root isnâ€™t 404)
 */
const DP_BASE = "https://dialpad.com/api/v2";

// ðŸ”‘ TEST KEY â€” INSECURE; ROTATE LATER
const TEST_DIALPAD_API_KEY =
  "2mC9tWMAaULL4SYSEJkK3z3x9nc2YyBKmWHxDc7tTv8azdYfAfRB6WxaNQf68ea8VS6mbYYdvqZVkcTvqwBfGuek9zFcS7qdMuNB";

const apiKey = (env) => (env && env.DIALPAD_API_KEY) ? env.DIALPAD_API_KEY : TEST_DIALPAD_API_KEY;

const cors = () => ({
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
});
const json = (data, status = 200) =>
  new Response(JSON.stringify(data), { status, headers: { "content-type": "application/json; charset=utf-8", ...cors() } });

const toDate = (n) => { const x = Number(n); if (!x || !isFinite(x)) return null; return new Date(x > 1e12 ? x : x * 1000); };
const startOfDay = (d) => { d = new Date(d); d.setHours(0,0,0,0); return d; };
const endOfDay   = (d) => { d = new Date(d); d.setHours(23,59,59,999); return d; };
const isoDay = (d) => new Date(d).toISOString().slice(0,10);

function callDurSec(c){
  let d = Number(c.duration);
  if (isFinite(d) && d > 0){ if (d > 100000) d/=1000; return d; }
  const a = Number(c.date_connected || c.date_started);
  const b = Number(c.date_ended || c.date_connected);
  if (isFinite(a) && isFinite(b) && b>a){ const diff=b-a; return diff>1e11?diff/1000:diff; }
  return 0;
}
const callTs = (obj) => { const c = obj.call || obj; return c.event_timestamp || c.date_started || c.date_connected || 0; };

async function dpPage(env, cursor=null){
  const u = new URL(DP_BASE + "/call");
  u.searchParams.set("limit","50");
  if (cursor) u.searchParams.set("cursor", cursor);
  const r = await fetch(u.toString(), {
    headers: { Authorization:`Bearer ${apiKey(env)}`, Accept:"application/json" }
  });
  if (!r.ok) throw new Error(`Dialpad ${r.status}`);
  return r.json();
}

async function aggregateDay(env, dayISO, pageCap=80, {force=false}={}){
  const cacheKey = `lb:day:${dayISO}`;
  if (!force && env && env.LB_CACHE){
    const cached = await env.LB_CACHE.get(cacheKey, "json");
    if (cached) return cached;
  }
  const from = startOfDay(dayISO), to = endOfDay(dayISO);
  let cursor=null, pages=0;
  const totals={ dials:0,inbound:0,outbound:0,answered:0,missed:0,sumDur:0 };
  const users=new Map();

  while(true){
    const page = await dpPage(env, cursor);
    pages++;
    const items = page.items || [];
    let crossed=false;
    for(const obj of items){
      const c = obj.call || obj;
      const d = toDate(callTs(obj));
      if(!d) continue;
      if(d>to) continue;
      if(d<from){ crossed=true; continue; }

      const dir=(c.direction||"").toLowerCase();
      const dur=callDurSec(c);
      totals.dials++;
      if(dir==="inbound") totals.inbound++; else if(dir==="outbound") totals.outbound++;
      if(dur>0) totals.answered++; else totals.missed++;
      totals.sumDur+=dur;

      const user=(c.target && (c.target.email||c.target.name)) || "Unknown";
      if(!users.has(user)) users.set(user,{ user,dials:0,inbound:0,outbound:0,answered:0,missed:0,duration:0 });
      const s=users.get(user);
      s.dials++; if(dir==="inbound") s.inbound++; else if(dir==="outbound") s.outbound++;
      if(dur>0) s.answered++; else s.missed++;
      s.duration+=dur;
    }
    if(!page.cursor || crossed || pages>=pageCap) break;
    cursor=page.cursor;
  }

  const rows=[...users.values()].map(s=>({ ...s, avg: s.answered ? (s.duration/s.answered) : 0 }));
  const result={ day:dayISO, totals, rows, pages, refreshedAt:new Date().toISOString() };
  if (env && env.LB_CACHE){
    await env.LB_CACHE.put(cacheKey, JSON.stringify(result), { expirationTtl: 60*60*24*30 });
  }
  return result;
}

function mergeAggregates(dayAggs){
  const totals={ dials:0,inbound:0,outbound:0,answered:0,missed:0,sumDur:0 };
  const users=new Map(); let pages=0;
  for(const agg of dayAggs){
    pages+=agg.pages||0;
    totals.dials+=agg.totals.dials; totals.inbound+=agg.totals.inbound;
    totals.outbound+=agg.totals.outbound; totals.answered+=agg.totals.answered;
    totals.missed+=agg.totals.missed; totals.sumDur+=agg.totals.sumDur;
    for(const r of agg.rows){
      if(!users.has(r.user)) users.set(r.user,{ user:r.user,dials:0,inbound:0,outbound:0,answered:0,missed:0,duration:0 });
      const s=users.get(r.user);
      s.dials+=r.dials; s.inbound+=r.inbound; s.outbound+=r.outbound;
      s.answered+=r.answered; s.missed+=r.missed; s.duration+=r.duration;
    }
  }
  const rows=[...users.values()].map(s=>({ ...s, avg: s.answered ? (s.duration/s.answered) : 0 }));
  return { totals, rows, pages };
}

export default {
  async fetch(req, env){
    const url = new URL(req.url);
    const path = url.pathname.replace(/\/+$/,''); // strip trailing slash

    if (req.method === "OPTIONS") return new Response(null, { headers: cors() });
    if (req.method !== "GET")     return json({ error:"Method not allowed" }, 405);

    // Friendly root
    if (path === "") {
      return json({
        ok: true,
        usage: {
          calls:        "/calls?limit=50[&cursor=...]",
          leaderboard:  "/leaderboard?from=YYYY-MM-DD&to=YYYY-MM-DD[&cap=80][&force=true]"
        },
        note: "This is the root of ve-dialpad-proxy. Use the endpoints above.",
      });
    }

    if (path === "/calls"){
      const u = new URL(DP_BASE + "/call");
      for (const [k,v] of url.searchParams) u.searchParams.set(k,v);
      if (!u.searchParams.get("limit")) u.searchParams.set("limit","50");
      const r = await fetch(u.toString(), {
        headers: { Authorization:`Bearer ${apiKey(env)}`, Accept:"application/json" }
      });
      const body = await r.text();
      return new Response(body, { status:r.status, headers:{ "content-type":"application/json; charset=utf-8", ...cors() } });
    }

    if (path === "/leaderboard"){
      const fromStr = url.searchParams.get("from");
      const toStr   = url.searchParams.get("to");
      if(!fromStr || !toStr) return json({ error:"from/to required (YYYY-MM-DD)" }, 400);

      const from = startOfDay(fromStr), to = endOfDay(toStr);
      if (to < from) return json({ error:"invalid range" }, 400);

      const cap   = Math.max(1, parseInt(url.searchParams.get("cap") || "80", 10));
      const force = (url.searchParams.get("force") || "false").toLowerCase() === "true";

      const days=[];
      for(let d=new Date(from); d<=to; d=new Date(d.getTime()+86400000)){
        days.push(isoDay(d));
      }
      const results = await Promise.all(days.map(day => aggregateDay(env, day, cap, { force })));
      const merged  = mergeAggregates(results);
      return json({ range:{ from:fromStr, to:toStr }, pages:merged.pages, totals:merged.totals, rows:merged.rows });
    }

    return json({ error:"Not found" }, 404);
  },

  // Hourly refresh for TODAY and YESTERDAY (if you add a Cron trigger)
  async scheduled(event, env){
    try{
      const now = new Date();
      const todayISO = isoDay(now);
      const yISO     = isoDay(new Date(now.getFullYear(), now.getMonth(), now.getDate()-1));
      await aggregateDay(env, todayISO, 120, { force:true });
      await aggregateDay(env, yISO,     120, { force:true });
    }catch(e){ console.error("scheduled error", e); }
  }
};





