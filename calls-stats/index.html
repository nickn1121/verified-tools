<script>
// ===== CONFIG =====
const WORKER_URL = "https://ve-dialpad-proxy.nick-north.workers.dev/calls"; // your worker
const PAGE_LIMIT = 50;     // Dialpad max per page
const MAX_AUTO_PAGES = 10; // safety stop when auto-loading
// ==================

const el = id => document.getElementById(id);
const fmt = s => {
  const sec = Math.round(Number(s||0));
  const m = Math.floor(sec/60), r = sec%60;
  return `${m}:${String(r).padStart(2,'0')}`;
};
const startOfDay = d => { d=new Date(d); d.setHours(0,0,0,0); return d; };
const endOfDay = d => { d=new Date(d); d.setHours(23,59,59,999); return d; };

let cursor = null;
let collected = [];
let range = {from: null, to: null};

function setStatus(t){ const s=el('status'); s.style.display='inline-block'; s.textContent=t; }
function clearStatus(){ el('status').style.display='none'; }

function calcRange() {
  const mode = el('range').value;
  const now = new Date();
  if (mode === 'today') return { from: startOfDay(now), to: endOfDay(now) };
  if (mode === 'week') {
    const day = now.getDay(); const diff = (day===0?6:day-1);
    const from = startOfDay(new Date(now - diff*86400000)); return { from, to: endOfDay(now) };
  }
  if (mode === 'month') return { from: new Date(now.getFullYear(), now.getMonth(), 1), to: endOfDay(now) };
  // custom
  return { from: new Date(el('from').value), to: new Date(el('to').value) };
}

async function fetchPage(nextCursor=null){
  const url = new URL(WORKER_URL);
  url.searchParams.set('limit', PAGE_LIMIT);
  if (nextCursor) url.searchParams.set('cursor', nextCursor);
  const r = await fetch(url.toString());
  if(!r.ok) throw new Error('Dialpad proxy failed');
  return r.json();
}

function inRange(call){
  // Dialpad returns either top-level timestamps or inside "call"
  const ts = Number(call.event_timestamp || call.call?.event_timestamp || 0);
  if (!ts) return false;
  const t = new Date(ts);
  return t >= range.from && t <= range.to;
}

function summarise(items){
  const totals = {total:0,in:0,out:0,ans:0,miss:0,sumDur:0};
  const map = new Map(); // user -> stats
  for(const c of items){
    const call = c.call || c; // normalize
    totals.total++;
    const dir = (call.direction||'').toLowerCase();
    if(dir==='inbound') totals.in++; else if(dir==='outbound') totals.out++;
    const dur = Number(call.duration||0);
    if(dur>0) totals.ans++; else totals.miss++;
    totals.sumDur += dur;

    const user = (call.target && (call.target.email || call.target.name)) || 'Unknown';
    if(!map.has(user)) map.set(user, {in:0,out:0,ans:0,miss:0,total:0,sumDur:0});
    const s = map.get(user);
    s.total++; s.sumDur += dur;
    if(dir==='inbound') s.in++; else if(dir==='outbound') s.out++;
    if(dur>0) s.ans++; else s.miss++;
  }
  return { totals, byUser:[...map.entries()] };
}

function renderKPIs({totals}){
  el('k_total').textContent = totals.total;
  el('k_in').textContent = totals.in;
  el('k_out').textContent = totals.out;
  el('k_ans').textContent = totals.ans;
  el('k_miss').textContent = totals.miss;
  el('k_avg').textContent = totals.total ? fmt(totals.sumDur/totals.total) : '0:00';
}

function renderByUser(byUser){
  const tbody = document.querySelector('#byUser tbody');
  tbody.innerHTML = '';
  byUser.sort((a,b)=>b[1].total-a[1].total).forEach(([user,s])=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${user}</td>
      <td>${s.in}</td><td>${s.out}</td>
      <td>${s.ans}</td><td>${s.miss}</td>
      <td>${s.total}</td><td>${fmt(s.sumDur/Math.max(1,s.total))}</td>`;
    tbody.appendChild(tr);
  });
}

function renderRows(items, append=false){
  const tbody = document.querySelector('#raw tbody');
  if(!append) tbody.innerHTML='';
  for(const c of items){
    const call = c.call || c;
    const when = call.event_timestamp ? new Date(Number(call.event_timestamp)).toLocaleString() : '';
    const user = (call.target && (call.target.email || call.target.name)) || '';
    const num  = call.external_number || call.internal_number || '';
    const rec = (call.admin_recording_urls && call.admin_recording_urls[0]) || (call.recording_details && call.recording_details[0]?.url) || '';
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${when}</td>
      <td>${user}</td>
      <td>${(call.direction||'').toLowerCase()}</td>
      <td>${num}</td>
      <td>${call.state || ''}</td>
      <td style="text-align:right">${fmt(call.duration||0)}</td>
      <td>${rec?`<a href="${rec}" target="_blank">link</a>`:''}</td>`;
    tbody.appendChild(tr);
  }
}

async function loadInitial(){
  setStatus('Loading…');
  collected = [];
  cursor = null;
  range = calcRange();

  const userFilter = el('userFilter').value.trim().toLowerCase();

  // Fetch first page and then auto-fetch more until we pass the date range or hit the safety cap
  let pages = 0;
  let more = true;

  while(more){
    const page = await fetchPage(cursor);
    cursor = page.cursor || null;
    let items = (page.items || []);
    // keep only calls in range
    items = items.filter(inRange);
    if(userFilter) items = items.filter(c => {
      const call = c.call || c;
      return (call.target?.email || '').toLowerCase().includes(userFilter);
    });

    collected = collected.concat(items);
    renderRows(items, pages>0);

    // If Dialpad is sorted newest→oldest, we can stop once oldest item we received is before the range start
    const pageOldestTs = Math.min(...(page.items||[]).map(x => Number((x.call?.event_timestamp ?? x.event_timestamp) || Infinity)));
    if (!cursor || !isFinite(pageOldestTs) || new Date(pageOldestTs) < range.from || ++pages >= MAX_AUTO_PAGES) {
      more = false;
    }
  }

  const summary = summarise(collected);
  renderKPIs(summary);
  renderByUser(summary.byUser);

  el('more').disabled = !cursor;
  el('moreInfo').textContent = cursor ? 'More available…' : 'All loaded';
  clearStatus();
}

async function loadMore(){
  if(!cursor) return;
  setStatus('Loading more…');
  const userFilter = el('userFilter').value.trim().toLowerCase();

  const page = await fetchPage(cursor);
  cursor = page.cursor || null;

  let items = (page.items || []).filter(inRange);
  if(userFilter) items = items.filter(c => {
    const call = c.call || c;
    return (call.target?.email || '').toLowerCase().includes(userFilter);
  });

  collected = collected.concat(items);
  renderRows(items, true);

  const summary = summarise(collected);
  renderKPIs(summary);
  renderByUser(summary.byUser);

  el('more').disabled = !cursor;
  el('moreInfo').textContent = cursor ? 'More available…' : 'All loaded';
  clearStatus();
}

// UI wiring
el('range').addEventListener('change', e=>{
  const custom = e.target.value==='custom';
  el('from').style.display = custom ? '' : 'none';
  el('to').style.display = custom ? '' : 'none';
});
el('load').addEventListener('click', loadInitial);
el('more').addEventListener('click', loadMore);

// Auto-load on open
loadInitial();
</script>

